package app.marlboroadvance.mpvex.utils.media

import android.content.Context
import android.media.MediaMetadataRetriever
import android.net.Uri
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import net.mediaarea.mediainfo.lib.MediaInfo

object MediaInfoOps {
  private const val TAG = "MediaInfoOps"

  /**
   * Extract detailed media information from a video file
   */
  suspend fun getMediaInfo(
    context: Context,
    uri: Uri,
    fileName: String,
  ): Result<MediaInfoData> =
    withContext(Dispatchers.IO) {
      runCatching {
        val contentResolver = context.contentResolver
        val pfd =
          contentResolver.openFileDescriptor(uri, "r")
            ?: return@runCatching MediaInfoData.empty()

        val fd = pfd.detachFd()
        val mi = MediaInfo()

        try {
          mi.Open(fd, fileName)

          val generalInfo = extractGeneralInfo(mi)
          val videoStreams = extractVideoStreams(mi)
          val audioStreams = extractAudioStreams(mi)
          val textStreams = extractTextStreams(mi)

          MediaInfoData(
            general = generalInfo,
            videoStreams = videoStreams,
            audioStreams = audioStreams,
            textStreams = textStreams,
          )
        } finally {
          mi.Close()
          pfd.close()
        }
      }
    }

  /**
   * Generate formatted text output from MediaInfoData using native MediaInfo Text format
   */
  suspend fun generateTextOutput(
    context: Context,
    uri: Uri,
    fileName: String,
  ): Result<String> =
    withContext(Dispatchers.IO) {
      runCatching {
        val contentResolver = context.contentResolver
        val pfd =
          contentResolver.openFileDescriptor(uri, "r")
            ?: return@runCatching "Error: Could not open file"

        val fd = pfd.detachFd()
        val mi = MediaInfo()

        try {
          mi.Open(fd, fileName)

          // Set output format to Text (human-readable format like MediaInfo desktop app)
          mi.Option("Inform", "Text")

          // Get the formatted text output
          val textOutput = mi.Inform()

          buildString {
            appendLine("=".repeat(60))
            appendLine("MEDIA INFO - $fileName")
            appendLine("=".repeat(60))
            appendLine()
            append(textOutput)
            appendLine()
            appendLine("=".repeat(60))
            appendLine("Generated by mpvex using MediaInfoLib")
            appendLine("=".repeat(60))
          }
        } finally {
          mi.Close()
          pfd.close()
        }
      }
    }

  private fun MediaInfo.getInfo(
    stream: MediaInfo.Stream,
    index: Int,
    parameter: String,
  ): String = Get(stream, index, parameter)

  private fun extractGeneralInfo(mi: MediaInfo): GeneralInfo =
    GeneralInfo(
      completeName = mi.getInfo(MediaInfo.Stream.General, 0, "CompleteName"),
      format = mi.getInfo(MediaInfo.Stream.General, 0, "Format"),
      formatVersion = mi.getInfo(MediaInfo.Stream.General, 0, "Format_Version"),
      fileSize = mi.getInfo(MediaInfo.Stream.General, 0, "FileSize/String"),
      duration = mi.getInfo(MediaInfo.Stream.General, 0, "Duration/String3"),
      overallBitRate = mi.getInfo(MediaInfo.Stream.General, 0, "OverallBitRate/String"),
      frameRate = mi.getInfo(MediaInfo.Stream.General, 0, "FrameRate/String"),
      title = mi.getInfo(MediaInfo.Stream.General, 0, "Title"),
      encodedDate = mi.getInfo(MediaInfo.Stream.General, 0, "Encoded_Date"),
      writingApplication = mi.getInfo(MediaInfo.Stream.General, 0, "Encoded_Application/String"),
      writingLibrary = mi.getInfo(MediaInfo.Stream.General, 0, "Encoded_Library/String"),
    )

  private fun extractVideoStreams(mi: MediaInfo): List<VideoStreamInfo> {
    val count = mi.Count_Get(MediaInfo.Stream.Video)
    return (0 until count).map { i ->
      VideoStreamInfo(
        streamIndex = i,
        id = mi.getInfo(MediaInfo.Stream.Video, i, "ID"),
        format = mi.getInfo(MediaInfo.Stream.Video, i, "Format"),
        formatInfo = mi.getInfo(MediaInfo.Stream.Video, i, "Format/Info"),
        formatProfile = mi.getInfo(MediaInfo.Stream.Video, i, "Format_Profile"),
        codecId = mi.getInfo(MediaInfo.Stream.Video, i, "CodecID"),
        duration = mi.getInfo(MediaInfo.Stream.Video, i, "Duration/String3"),
        bitRate = mi.getInfo(MediaInfo.Stream.Video, i, "BitRate/String"),
        width = mi.getInfo(MediaInfo.Stream.Video, i, "Width/String"),
        height = mi.getInfo(MediaInfo.Stream.Video, i, "Height/String"),
        displayAspectRatio = mi.getInfo(MediaInfo.Stream.Video, i, "DisplayAspectRatio/String"),
        frameRate = mi.getInfo(MediaInfo.Stream.Video, i, "FrameRate/String"),
        frameRateMode = mi.getInfo(MediaInfo.Stream.Video, i, "FrameRate_Mode"),
        colorSpace = mi.getInfo(MediaInfo.Stream.Video, i, "ColorSpace"),
        chromaSubsampling = mi.getInfo(MediaInfo.Stream.Video, i, "ChromaSubsampling"),
        bitDepth = mi.getInfo(MediaInfo.Stream.Video, i, "BitDepth/String"),
        bitsPixelFrame = mi.getInfo(MediaInfo.Stream.Video, i, "Bits-(Pixel*Frame)"),
        streamSize = mi.getInfo(MediaInfo.Stream.Video, i, "StreamSize/String"),
        encodingLibrary = mi.getInfo(MediaInfo.Stream.Video, i, "Encoded_Library/String"),
        defaultStream = mi.getInfo(MediaInfo.Stream.Video, i, "Default/String"),
        forcedStream = mi.getInfo(MediaInfo.Stream.Video, i, "Forced/String"),
        hdrFormat = mi.getInfo(MediaInfo.Stream.Video, i, "HDR_Format"),
        maxCLL = mi.getInfo(MediaInfo.Stream.Video, i, "MaxCLL"),
        maxFALL = mi.getInfo(MediaInfo.Stream.Video, i, "MaxFALL"),
      )
    }
  }

  private fun extractAudioStreams(mi: MediaInfo): List<AudioStreamInfo> {
    val count = mi.Count_Get(MediaInfo.Stream.Audio)
    return (0 until count).map { i ->
      AudioStreamInfo(
        streamIndex = i,
        id = mi.getInfo(MediaInfo.Stream.Audio, i, "ID"),
        format = mi.getInfo(MediaInfo.Stream.Audio, i, "Format"),
        formatInfo = mi.getInfo(MediaInfo.Stream.Audio, i, "Format/Info"),
        codecId = mi.getInfo(MediaInfo.Stream.Audio, i, "CodecID"),
        duration = mi.getInfo(MediaInfo.Stream.Audio, i, "Duration/String3"),
        bitRate = mi.getInfo(MediaInfo.Stream.Audio, i, "BitRate/String"),
        channels = mi.getInfo(MediaInfo.Stream.Audio, i, "Channel(s)/String"),
        channelLayout = mi.getInfo(MediaInfo.Stream.Audio, i, "ChannelLayout"),
        samplingRate = mi.getInfo(MediaInfo.Stream.Audio, i, "SamplingRate/String"),
        frameRate = mi.getInfo(MediaInfo.Stream.Audio, i, "FrameRate/String"),
        compressionMode = mi.getInfo(MediaInfo.Stream.Audio, i, "Compression_Mode"),
        delay = mi.getInfo(MediaInfo.Stream.Audio, i, "Video_Delay/String3"),
        streamSize = mi.getInfo(MediaInfo.Stream.Audio, i, "StreamSize/String"),
        title = mi.getInfo(MediaInfo.Stream.Audio, i, "Title"),
        language = mi.getInfo(MediaInfo.Stream.Audio, i, "Language/String"),
        defaultStream = mi.getInfo(MediaInfo.Stream.Audio, i, "Default/String"),
        forcedStream = mi.getInfo(MediaInfo.Stream.Audio, i, "Forced/String"),
      )
    }
  }

  private fun extractTextStreams(mi: MediaInfo): List<TextStreamInfo> {
    val count = mi.Count_Get(MediaInfo.Stream.Text)
    return (0 until count).map { i ->
      TextStreamInfo(
        streamIndex = i,
        id = mi.getInfo(MediaInfo.Stream.Text, i, "ID"),
        format = mi.getInfo(MediaInfo.Stream.Text, i, "Format"),
        muxingMode = mi.getInfo(MediaInfo.Stream.Text, i, "MuxingMode"),
        codecId = mi.getInfo(MediaInfo.Stream.Text, i, "CodecID"),
        codecIdInfo = mi.getInfo(MediaInfo.Stream.Text, i, "CodecID/Info"),
        duration = mi.getInfo(MediaInfo.Stream.Text, i, "Duration/String3"),
        bitRate = mi.getInfo(MediaInfo.Stream.Text, i, "BitRate/String"),
        frameRate = mi.getInfo(MediaInfo.Stream.Text, i, "FrameRate/String"),
        countOfElements = mi.getInfo(MediaInfo.Stream.Text, i, "ElementCount"),
        streamSize = mi.getInfo(MediaInfo.Stream.Text, i, "StreamSize/String"),
        title = mi.getInfo(MediaInfo.Stream.Text, i, "Title"),
        language = mi.getInfo(MediaInfo.Stream.Text, i, "Language/String"),
        defaultStream = mi.getInfo(MediaInfo.Stream.Text, i, "Default/String"),
        forcedStream = mi.getInfo(MediaInfo.Stream.Text, i, "Forced/String"),
      )
    }
  }

  data class MediaInfoData(
    val general: GeneralInfo,
    val videoStreams: List<VideoStreamInfo>,
    val audioStreams: List<AudioStreamInfo>,
    val textStreams: List<TextStreamInfo>,
  ) {
    companion object {
      fun empty() =
        MediaInfoData(
          general = GeneralInfo(),
          videoStreams = emptyList(),
          audioStreams = emptyList(),
          textStreams = emptyList(),
        )
    }
  }

  data class GeneralInfo(
    val completeName: String = "",
    val format: String = "",
    val formatVersion: String = "",
    val fileSize: String = "",
    val duration: String = "",
    val overallBitRate: String = "",
    val frameRate: String = "",
    val title: String = "",
    val encodedDate: String = "",
    val writingApplication: String = "",
    val writingLibrary: String = "",
  )

  data class VideoStreamInfo(
    val streamIndex: Int,
    val id: String = "",
    val format: String = "",
    val formatInfo: String = "",
    val formatProfile: String = "",
    val codecId: String = "",
    val duration: String = "",
    val bitRate: String = "",
    val width: String = "",
    val height: String = "",
    val displayAspectRatio: String = "",
    val frameRate: String = "",
    val frameRateMode: String = "",
    val colorSpace: String = "",
    val chromaSubsampling: String = "",
    val bitDepth: String = "",
    val bitsPixelFrame: String = "",
    val streamSize: String = "",
    val encodingLibrary: String = "",
    val defaultStream: String = "",
    val forcedStream: String = "",
    val hdrFormat: String = "",
    val maxCLL: String = "",
    val maxFALL: String = "",
  )

  data class AudioStreamInfo(
    val streamIndex: Int,
    val id: String = "",
    val format: String = "",
    val formatInfo: String = "",
    val codecId: String = "",
    val duration: String = "",
    val bitRate: String = "",
    val channels: String = "",
    val channelLayout: String = "",
    val samplingRate: String = "",
    val frameRate: String = "",
    val compressionMode: String = "",
    val delay: String = "",
    val streamSize: String = "",
    val title: String = "",
    val language: String = "",
    val defaultStream: String = "",
    val forcedStream: String = "",
  )

  data class TextStreamInfo(
    val streamIndex: Int,
    val id: String = "",
    val format: String = "",
    val muxingMode: String = "",
    val codecId: String = "",
    val codecIdInfo: String = "",
    val duration: String = "",
    val bitRate: String = "",
    val frameRate: String = "",
    val countOfElements: String = "",
    val streamSize: String = "",
    val title: String = "",
    val language: String = "",
    val defaultStream: String = "",
    val forcedStream: String = "",
  )

  private suspend fun tryExtractWithRetriever(
    context: Context,
    uri: Uri,
  ): VideoMetadata? =
    withContext(Dispatchers.IO) {
      runCatching {
        val retriever = MediaMetadataRetriever()
        try {
          retriever.setDataSource(context, uri)

          val durationStr = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)
          val duration = durationStr?.toLongOrNull() ?: 0L

          val widthStr = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH)
          val heightStr = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT)
          val width = widthStr?.toIntOrNull() ?: 0
          val height = heightStr?.toIntOrNull() ?: 0

          val fpsString = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_CAPTURE_FRAMERATE)
          val fps = fpsString?.toFloatOrNull() ?: 0f

          if (duration > 0 && width > 0 && height > 0) {
            VideoMetadata(0L, duration, width, height, fps)
          } else {
            null
          }
        } finally {
          retriever.release()
        }
      }.getOrNull()
    }

  suspend fun extractBasicMetadata(
    context: Context,
    uri: Uri,
    fileName: String,
  ): Result<VideoMetadata> =
    withContext(Dispatchers.IO) {
      runCatching {
        val retrieverMetadata = tryExtractWithRetriever(context, uri)

        if (retrieverMetadata != null && retrieverMetadata.width > 0 && retrieverMetadata.height > 0) {
          if (retrieverMetadata.fps > 0f) {
            return@runCatching retrieverMetadata
          } else {
            val fps = extractFramerateFromMediaInfo(context, uri, fileName)
            return@runCatching retrieverMetadata.copy(fps = fps)
          }
        }

        val contentResolver = context.contentResolver
        val pfd =
          contentResolver.openFileDescriptor(uri, "r")
            ?: return@runCatching VideoMetadata(0L, 0L, 0, 0, 0f)

        val fd = pfd.detachFd()
        val mi = MediaInfo()

        try {
          mi.Open(fd, fileName)

          val fileSizeStr = mi.getInfo(MediaInfo.Stream.General, 0, "FileSize")
          val fileSize = fileSizeStr.toLongOrNull() ?: 0L

          val durationStr = mi.getInfo(MediaInfo.Stream.General, 0, "Duration")
          val duration = durationStr.toLongOrNull() ?: 0L

          val widthStr = mi.getInfo(MediaInfo.Stream.Video, 0, "Width")
          val width = widthStr.toIntOrNull() ?: 0

          val heightStr = mi.getInfo(MediaInfo.Stream.Video, 0, "Height")
          val height = heightStr.toIntOrNull() ?: 0

          val fpsStr = mi.getInfo(MediaInfo.Stream.Video, 0, "FrameRate")
          val fps = fpsStr.toFloatOrNull() ?: 0f

          VideoMetadata(fileSize, duration, width, height, fps)
        } finally {
          mi.Close()
          pfd.close()
        }
      }
    }

  private suspend fun extractFramerateFromMediaInfo(
    context: Context,
    uri: Uri,
    fileName: String,
  ): Float =
    withContext(Dispatchers.IO) {
      runCatching {
        val contentResolver = context.contentResolver
        val pfd = contentResolver.openFileDescriptor(uri, "r") ?: return@withContext 0f

        val fd = pfd.detachFd()
        val mi = MediaInfo()

        try {
          mi.Open(fd, fileName)
          val fpsStr = mi.getInfo(MediaInfo.Stream.Video, 0, "FrameRate")
          fpsStr.toFloatOrNull() ?: 0f
        } finally {
          mi.Close()
          pfd.close()
        }
      }.getOrElse { 0f }
    }

  data class VideoMetadata(
    val sizeBytes: Long,
    val durationMs: Long,
    val width: Int,
    val height: Int,
    val fps: Float,
  )
}
